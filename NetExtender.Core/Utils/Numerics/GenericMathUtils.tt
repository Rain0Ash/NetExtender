<#@ template language="C#v3.5" #>
<#@ output extension=".cs" encoding="utf-8"#>
<#@ assembly name="System.Core"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

using System;
using System.Numerics;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace NetExtender.Utils.Numerics
{
<#
    List<Type> vtypes = new List<Type>
    {
        typeof(Char),
        typeof(SByte),
        typeof(Byte),
        typeof(Int16),
        typeof(UInt16),
        typeof(Int32),
        typeof(UInt32),
        typeof(Int64),
        typeof(UInt64),
        typeof(Single),
        typeof(Double),
        typeof(Decimal)
    };

    List<String> types = new List<String>
    {
        nameof(Char),
        nameof(SByte),
        nameof(Byte),
        nameof(Int16),
        nameof(UInt16),
        nameof(Int32),
        nameof(UInt32),
        nameof(Int64),
        nameof(UInt64),
        nameof(Single),
        nameof(Double),
        nameof(Decimal)
    };

    Dictionary<String, Type> typedict = vtypes.ToDictionary(type => type.Name, type => type);

    Dictionary<String, String> operands = new Dictionary<String, String>
    {
        {"+", "Add"},
        {"-", "Substract"},
        {"*", "Multiply"},
        {"/", "Divide"},
        {"%", "Modulo"},
        {"&", "And"},
        {"|", "Or"},
        {"^", "Xor"},
        {"~", "Invert"},
        {"| |", "Abs"},
        {"-| |", "Negative"},
        {"==", "Equal"},
        {"!=", "NotEqual"},
        {">", "Greater"},
        {">=", "GreaterEqual"},
        {"<", "Less"},
        {"<=", "LessEqual"}
    };

    const String biginteger = "BigInteger";

    static Boolean NotChar(String type)
    {
        return type != nameof(Char);
    }
    
    static Boolean IsSmallType(String type)
    {
        return type == nameof(Char) || type == nameof(Byte) || type == nameof(SByte) || type == nameof(Int16) || type == nameof(UInt16);
    }

    static Boolean IsUnsignedType(String type)
    {
        return type == nameof(Char) || type == nameof(Byte) || type == nameof(UInt16) || type == nameof(UInt32) || type == nameof(UInt64);
    }
    
    Boolean IsIntType(String type)
    {
        return type == nameof(Char) || type == nameof(SByte) || type == nameof(Byte) || type == nameof(Int16) || type == nameof(UInt16) || type == nameof(Int32) || type == nameof(UInt32) || type == nameof(Int64) || type == nameof(UInt64) || type == biginteger;
    }

    String ToLessType(String type, String second)
    {
        if (type == second)
        {
            return type;
        }

        return (Marshal.SizeOf(typedict[type]) - Marshal.SizeOf(typedict[second])) switch
        {
            < 0 => type,
            0 => ToSignedType(type),
            > 0 => second
        };
    }
    
    String ToGreaterType(String type, String second)
    {
        if (type == second)
        {
            return type;
        }

        return (Marshal.SizeOf(typedict[type]) - Marshal.SizeOf(typedict[second])) switch
        {
            < 0 => second,
            0 => ToUnsignedType(type),
            > 0 => type
        };
    }
    
    static String ToSignedType(String type)
    {
        return type switch
        {
            nameof(Byte) => nameof(SByte),
            nameof(UInt16) => nameof(Int16),
            nameof(UInt32) => nameof(Int32),
            nameof(UInt64) => nameof(Int64),
            _ => type
        };
    }

    static String ToUnsignedType(String type)
    {
        return type switch
        {
            nameof(SByte) => nameof(Byte),
            nameof(Int16) => nameof(UInt16),
            nameof(Int32) => nameof(UInt32),
            nameof(Int64) => nameof(UInt64),
            _ => type
        };
    }

    void ForEach(IEnumerable<String> types, Action<String> action, Boolean line = true)
    {
        String[] type = types.ToArray();

        for (Int32 i = 0; i < type.Length; i++)
        {
            action(type[i]);

            if (line && i <= type.Length - 2)
            {
                WriteLine(String.Empty);
            }
        }
    }

    void Functions(String @operator)
    {
        Boolean comparison = @operator == "==" || @operator == "!=" ||
                             @operator == ">" || @operator == ">=" ||
                             @operator == "<" || @operator == "<=";

        Boolean unary = @operator == "~" || @operator == "| |" || @operator == "-| |";

        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");

        WriteLine($"\t\tpublic static {(comparison ? nameof(Boolean) : "T")} {operands[@operator]}<T>({(unary ? "T value" : "T left, T right")}) where T : unmanaged, IConvertible");

        WriteLine("\t\t{");

        foreach (
            String type in
                types.Where(type => type != nameof(Single) && type != nameof(Double) && type != nameof(Decimal) || @operator != "&" && @operator != "|" && @operator != "^"))
        {
            Boolean unsigned = IsUnsignedType(type);
            Boolean small = IsSmallType(type);

            if (unsigned && (@operator == "| |" || @operator == "-| |") || @operator == "~" && (type == nameof(Single) || type == nameof(Double) || type == nameof(Decimal)))
            {
                continue;
            }

            WriteLine($"\t\t\tif (typeof(T) == typeof({type}))");
            WriteLine("\t\t\t{");

            String expression = $"Unsafe.As<T, {type}>(ref left) {@operator} Unsafe.As<T, {type}>(ref right)";

            if (!comparison && small)
            {
                expression = $"({type})({expression})";
            }


            if (comparison)
            {
                if ((type == nameof(Single) || type == nameof(Double)) && (@operator == "==" || @operator == "!="))
                {
                    expression = $"Math.Abs(Unsafe.As<T, {type}>(ref left) - Unsafe.As<T, {type}>(ref right)) {{0}} {type}.Epsilon";

                    expression = @operator switch
                    {
                        "==" => String.Format(expression, "<"),
                        "!=" => String.Format(expression, ">"),
                        _ => throw new NotSupportedException()
                        };
                }
                WriteLine($"\t\t\t\treturn {expression};");
            }
            else if (unary)
            {
                switch (@operator)
                {
                    case "~":
                        WriteLine($"\t\t\t\t{(small ? nameof(Int32) : $"{type}")} {(small ? "i" : "val")} = ~Unsafe.As<T, {type}>(ref value);");
                        if (small)
                        {
                            WriteLine($"\t\t\t\t{type} val = Unsafe.As<{nameof(Int32)}, {type}>(ref i);");
                        }

                        WriteLine($"\t\t\t\treturn Unsafe.As<{type}, T>(ref val);");
                        break;
                    case "| |":
                        WriteLine($"\t\t\t\t{type} val = Math.Abs(Unsafe.As<T, {type}>(ref value));");
                        WriteLine($"\t\t\t\treturn Unsafe.As<{type}, T>(ref val);");
                        break;
                    case "-| |":
                        WriteLine($"\t\t\t\t{(small ? nameof(Int32) : $"{type}")} {(small ? "i" : "val")} = -Math.Abs(Unsafe.As<T, {type}>(ref value));");
                        if (small)
                        {
                            WriteLine($"\t\t\t\t{type} val = Unsafe.As<{nameof(Int32)}, {type}>(ref i);");
                        }
                        WriteLine($"\t\t\t\treturn Unsafe.As<{type}, T>(ref val);");
                        break;
                    default:
                        throw new NotSupportedException();
                }
            }
            else
            {
                WriteLine($"\t\t\t\t{type} value = {expression};");
                WriteLine($"\t\t\t\treturn Unsafe.As<{type}, T>(ref value);");
            }
            
            WriteLine("\t\t\t}");
            WriteLine(String.Empty);
        }

        WriteLine($"\t\t\tthrow new NotSupportedException($\"Operator {@operator} is not supported for {{typeof(T)}} type\");");
        WriteLine("\t\t}");
        WriteLine(String.Empty);
    }

    void MinFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Min)}(this {type} value, {type} compare)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn value <= compare ? value : compare;");
        WriteLine("\t\t}");
    }
    
    void Min()
    {
        ForEach(types.Append(biginteger), MinFunc);
    }
    
    void MaxFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Max)}(this {type} value, {type} compare)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn value >= compare ? value : compare;");
        WriteLine("\t\t}");
    }
    
    void Max()
    {
        ForEach(types.Append(biginteger), MaxFunc);
    }

    void FactorialFunc(String type)
    {
        WriteLine($"\t\tpublic static {biginteger} Factorial(this {type} value)");
        WriteLine("\t\t{");

        if (!IsUnsignedType(type))
        {
            WriteLine("\t\t\tif (value < 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tthrow new ArgumentOutOfRangeException();");
            WriteLine("\t\t\t}");

            WriteLine(String.Empty);
        }

        if (!IsSmallType(type) && type != nameof(Int32) && type != nameof(UInt32))
        {
            WriteLine("\t\t\tif (value > UInt32.MaxValue)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tthrow new ArgumentOutOfRangeException();");
            WriteLine("\t\t\t}");

            WriteLine(String.Empty);
        }
        
        WriteLine("\t\t\treturn Factorial((UInt32)value);");
        
        WriteLine("\t\t}");
    }

    void Factorial()
    {
        ForEach(types.Where(NotChar).Where(IsIntType).Where(type => type != nameof(UInt32)).Append(biginteger), FactorialFunc);
    }

    void RangeFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static IEnumerable<{type}> {nameof(Range)}({type} stop)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(Range)}({(IsSmallType(type) ? $"({type}) " : String.Empty)}0, stop);");
        WriteLine("\t\t}");

        WriteLine(String.Empty);
        
        WriteLine($"\t\tpublic static IEnumerable<{type}> {nameof(Range)}({type} start, {type} stop, {type} step = 1)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tif ({(type == nameof(Single) || type == nameof(Double) ? $"Math.Abs(step) < {type}.Epsilon" : "step == 0")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentException(\"Step cannot be equals zero.\");");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);

        if (IsUnsignedType(type))
        {
            WriteLine($"\t\t\tfor ({type} i = start; i < stop; i += step)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tyield return i;");
            WriteLine("\t\t\t}");
        }
        else
        {
            WriteLine("\t\t\tif (start < stop && step > 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\tfor ({type} i = start; i < stop; i += step)");
            WriteLine("\t\t\t\t{");
            WriteLine("\t\t\t\t\tyield return i;");
            WriteLine("\t\t\t\t}");
            WriteLine("\t\t\t}");
            WriteLine("\t\t\telse if (start > stop && step < 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\tfor ({type} i = start; i > stop; i += step)");
            WriteLine("\t\t\t\t{");
            WriteLine("\t\t\t\t\tyield return i;");
            WriteLine("\t\t\t\t}");
            WriteLine("\t\t\t}");
        }

        WriteLine("\t\t}");
    }
    
    void Range()
    {
        ForEach(types.Where(NotChar), RangeFunc);
    }
    
    void RangeIncludeFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static IEnumerable<{type}> {nameof(RangeInclude)}({type} stop)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(RangeInclude)}({(IsSmallType(type) ? $"({type}) " : String.Empty)}0, stop);");
        WriteLine("\t\t}");

        WriteLine(String.Empty);
        
        WriteLine($"\t\tpublic static IEnumerable<{type}> {nameof(RangeInclude)}({type} start, {type} stop, {type} step = 1)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tif ({(type == nameof(Single) || type == nameof(Double) ? $"Math.Abs(step) < {type}.Epsilon" : "step == 0")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentException(\"Step cannot be equals zero.\");");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);

        if (IsUnsignedType(type))
        {
            WriteLine($"\t\t\tfor ({type} i = start; i <= stop; i += step)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tyield return i;");
            WriteLine("\t\t\t}");
        }
        else
        {
            WriteLine("\t\t\tif (start < stop && step > 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\tfor ({type} i = start; i <= stop; i += step)");
            WriteLine("\t\t\t\t{");
            WriteLine("\t\t\t\t\tyield return i;");
            WriteLine("\t\t\t\t}");
            WriteLine("\t\t\t}");
            WriteLine("\t\t\telse if (start > stop && step < 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\tfor ({type} i = start; i >= stop; i += step)");
            WriteLine("\t\t\t\t{");
            WriteLine("\t\t\t\t\tyield return i;");
            WriteLine("\t\t\t\t}");
            WriteLine("\t\t\t}");
        }

        WriteLine("\t\t}");
    }
    
    void RangeInclude()
    {
        ForEach(types.Where(NotChar), RangeIncludeFunc);
    }

    void ToRangeFunc(String type)
    {
        String func =
            $"public static {{0}} {nameof(ToRange)}({{1}}{type} value, {type} minimum = {(type == "Char" ? $"{type}.MinValue" : "0")}, {type} maximum = {type}.MaxValue, Boolean looped = {false.ToString().ToLower()})";

        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\t{String.Format(func, "void", "ref ")}");
        WriteLine("\t\t{");
        WriteLine($"\t\t\t value = {nameof(ToRange)}(value, minimum, maximum, looped);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);

        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\t{String.Format(func, type, "this ")}");
        WriteLine("\t\t{");
        WriteLine("\t\t\tif (value > maximum)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn looped ? minimum : maximum;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\tif (value < minimum)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn looped ? maximum : minimum;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\treturn value;");
        WriteLine("\t\t}");
    }

    void ToRange()
    {
        ForEach(types, ToRangeFunc);
    }

    void InRangeFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Boolean)} {nameof(InRange)}(this {type} value, MathPositionType comparison = MathPositionType.Both)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(InRange)}(value, default, {type}.MaxValue, comparison);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Boolean)} {nameof(InRange)}(this {type} value, {type} maximum, MathPositionType comparison = MathPositionType.Both)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(InRange)}(value, default, maximum, comparison);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine(
            $"\t\tpublic static {nameof(Boolean)} {nameof(InRange)}(this {type} value, {type} minimum, {type} maximum, MathPositionType comparison = MathPositionType.Both)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn comparison switch");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tMathPositionType.None => value > minimum && value < maximum,");
        WriteLine("\t\t\t\tMathPositionType.Left => value >= minimum && value < maximum,");
        WriteLine("\t\t\t\tMathPositionType.Right => value > minimum && value <= maximum,");
        WriteLine("\t\t\t\tMathPositionType.Both => value >= minimum && value <= maximum,");
        WriteLine("\t\t\t\t_ => throw new NotSupportedException()");
        WriteLine("\t\t\t};");
        WriteLine("\t\t}");
    }

    void InRange()
    {
        ForEach(types, InRangeFunc);
    }

    void IsPositiveFunc(String type)
    {
        if (IsUnsignedType(type))
        {
            WriteLine("\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"ReSharper\", \"UnusedParameter.Global\")]");
        }
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Boolean)} {nameof(IsPositive)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine(IsUnsignedType(type) ? "\t\t\treturn true;" : "\t\t\treturn value >= 0;");
        WriteLine("\t\t}");
    }
    
    void IsPositive()
    {
        ForEach(types.Append(biginteger), IsPositiveFunc);
    }
    
    void IsNegativeFunc(String type)
    {
        if (IsUnsignedType(type))
        {
            WriteLine("\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"ReSharper\", \"UnusedParameter.Global\")]");
        }
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Boolean)} {nameof(IsNegative)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine(IsUnsignedType(type) ? "\t\t\treturn false;" : "\t\t\treturn value < 0;");
        WriteLine("\t\t}");
    }
    
    void IsNegative()
    {
        ForEach(types.Append(biginteger), IsNegativeFunc);
    }
    
    void ToSignFunc(String type)
    {
        if (IsUnsignedType(type))
        {
            WriteLine("\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"ReSharper\", \"UnusedParameter.Global\")]");
        }
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Char)} {nameof(ToSign)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine(IsUnsignedType(type) ? "\t\t\treturn '+';" : "\t\t\treturn value >= 0 ? '+' : '-';");
        WriteLine("\t\t}");
    }
    
    void ToSign()
    {
        ForEach(types.Append(biginteger), ToSignFunc);
    }

    void RoundToMultiplierFunc(String type)
    {
        Boolean integer = IsIntType(type) || type == nameof(Decimal);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tprivate static {type} RoundUpToMultiplierOriginal({type} value, {type} multiplier)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn RoundUpToMultiplierOriginal(value, multiplier, value % multiplier);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tprivate static {type} RoundUpToMultiplierOriginal({type} value, {type} multiplier, {(IsSmallType(type) ? nameof(Int32) : type)} remainder)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {(integer ? "remainder == 0" : "IsEpsilon(remainder)")} ? value : {(IsSmallType(type) ? $"({type})(multiplier - remainder + value)" : "multiplier - remainder + value")};");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\tpublic static {type} RoundUpToMultiplier({type} value, {type} multiplier = 10)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tif ({(integer ? "multiplier == 0" : "IsEpsilon(multiplier)")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentException(nameof(multiplier));");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\tif ({(integer ? "value == 0" : "IsEpsilon(value)")} || {(integer ? $"value == multiplier || multiplier == 1{(!IsUnsignedType(type) ? " || multiplier == -1" : String.Empty)}" : "IsEpsilon(value - multiplier)")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn value;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);

        if (!IsUnsignedType(type))
        {
            WriteLine("\t\t\tif (value < 0 ^ multiplier < 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\treturn RoundDownToMultiplierOriginal(value, multiplier.Abs());");
            WriteLine("\t\t\t}");
            
            WriteLine(String.Empty);
        }

        WriteLine($"\t\t\t{(IsSmallType(type) ? nameof(Int32) : type)} remainder = value % multiplier;");
        WriteLine($"\t\t\treturn {(integer ? "remainder == 0" : "IsEpsilon(remainder)")} ? value : RoundUpToMultiplierOriginal(value, multiplier, remainder);");
        WriteLine("\t\t}");

        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tprivate static {type} RoundDownToMultiplierOriginal({type} value, {type} multiplier)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\t{(IsSmallType(type) ? $"{nameof(Int32)}" : $"{type}")} remainder = value % multiplier;");
        WriteLine($"\t\t\treturn {(integer ? "remainder == 0" : "IsEpsilon(remainder)")} ? value : {(IsSmallType(type) ? $"({type})(value - remainder)" : "value - remainder")};");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);

        WriteLine($"\t\tpublic static {type} RoundDownToMultiplier({type} value, {type} multiplier = 10)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tif ({(integer ? "multiplier == 0" : "IsEpsilon(multiplier)")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentException(nameof(multiplier));");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\tif ({(integer ? "value == 0" : "IsEpsilon(value)")} || {(integer ? $"value == multiplier || multiplier == 1{(!IsUnsignedType(type) ? " || multiplier == -1" : String.Empty)}" : "IsEpsilon(value - multiplier)")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn value;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);

        if (!IsUnsignedType(type))
        {
            WriteLine("\t\t\tif (value < 0 && multiplier < 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tif (value > multiplier)");
            WriteLine("\t\t\t\t{");
            WriteLine("\t\t\t\t\treturn 0;");
            WriteLine("\t\t\t\t}");
            
            WriteLine(String.Empty);
            
            WriteLine($"\t\t\t\tmultiplier = {(IsSmallType(type) ? $"({type})(-multiplier)" : "-multiplier")};");
            WriteLine("\t\t\t}");
            
            WriteLine(String.Empty);
            
            WriteLine("\t\t\tif (value < 0 || multiplier < 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\treturn {(IsSmallType(type) ? $"({type})(-RoundUpToMultiplierOriginal(-value, multiplier))" : "-RoundUpToMultiplierOriginal(-value, multiplier)")};");
            WriteLine("\t\t\t}");
            
            WriteLine(String.Empty);
        }
        
        WriteLine("\t\t\treturn RoundDownToMultiplierOriginal(value, multiplier);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\tpublic static {type} RoundBankingToMultiplier({type} value, {type} multiplier = 10)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tif ({(integer ? "multiplier == 0" : "IsEpsilon(multiplier)")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentException(nameof(multiplier));");
        WriteLine("\t\t\t}");
        
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\tif ({(integer ? "value == 0" : "IsEpsilon(value)")} || {(integer ? $"value == multiplier || multiplier == 1{(!IsUnsignedType(type) ? " || multiplier == -1" : String.Empty)}" : "IsEpsilon(value - multiplier)")})");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn value;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);

        if (IsUnsignedType(type))
        {
            WriteLine("\t\t\treturn value % multiplier >= multiplier / 2d ? RoundUpToMultiplierOriginal(value, multiplier) : RoundDownToMultiplierOriginal(value, multiplier);");
        }
        else
        {
            WriteLine($"\t\t\t{(IsSmallType(type) ? nameof(Int32) : type)} remainder = value % multiplier;");
            WriteLine($"\t\t\t{(type == nameof(Decimal) ? nameof(Decimal) : nameof(Double))} average = multiplier / 2{(type == nameof(Decimal) ? "m" : "d")};");
        
            WriteLine(String.Empty);
            
            WriteLine("\t\t\tif (value > 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tif (multiplier > 0)");
            WriteLine("\t\t\t\t{");
            WriteLine("\t\t\t\t\treturn remainder >= average ? RoundUpToMultiplierOriginal(value, multiplier) : RoundDownToMultiplierOriginal(value, multiplier);");
            WriteLine("\t\t\t\t}");

            WriteLine(String.Empty);
        
            WriteLine("\t\t\t\treturn remainder <= -average ? RoundUpToMultiplier(value, multiplier) : RoundDownToMultiplier(value, multiplier);");
            WriteLine("\t\t\t}");
        
            WriteLine(String.Empty);
        
            WriteLine("\t\t\tif (multiplier > 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\treturn remainder >= -average ? RoundUpToMultiplier(value, multiplier) : RoundDownToMultiplier(value, multiplier);");
            WriteLine("\t\t\t}");
        
            WriteLine(String.Empty);
        
            WriteLine("\t\t\treturn remainder <= average ? RoundUpToMultiplierOriginal(value, multiplier) : RoundDownToMultiplierOriginal(value, multiplier);");
        }
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} RoundToZeroMultiplier({type} value, {type} multiplier)");
        WriteLine("\t\t{");

        if (IsUnsignedType(type))
        {
            WriteLine("\t\t\treturn RoundDownToMultiplier(value, multiplier);");
        }
        else
        {
            WriteLine("\t\t\tif (value > 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\treturn multiplier > 0 ? RoundDownToMultiplier(value, multiplier) : RoundDownToMultiplier(value, {(IsSmallType(type) ? $"({type})(-multiplier)" : "-multiplier")});");
            WriteLine("\t\t\t}");
            
            WriteLine(String.Empty);
            
            WriteLine($"\t\t\treturn multiplier > 0 ? RoundDownToMultiplier(value, {(IsSmallType(type) ? $"({type})(-multiplier)" : "-multiplier")}) : RoundDownToMultiplier(value, multiplier);");
        }
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} RoundAwayFromZeroToMultiplier({type} value, {type} multiplier)");
        WriteLine("\t\t{");

        if (IsUnsignedType(type))
        {
            WriteLine("\t\t\treturn RoundUpToMultiplier(value, multiplier);");
        }
        else
        {
            WriteLine("\t\t\tif (value > 0)");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\treturn multiplier > 0 ? RoundUpToMultiplier(value, multiplier) : RoundUpToMultiplier(value, {(IsSmallType(type) ? $"({type})(-multiplier)" : "-multiplier")});");
            WriteLine("\t\t\t}");
            
            WriteLine(String.Empty);
            
            WriteLine($"\t\t\treturn multiplier > 0 ? RoundUpToMultiplier(value, {(IsSmallType(type) ? $"({type})(-multiplier)" : "-multiplier")}) : RoundUpToMultiplier(value, multiplier);");
        }
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\tpublic static {type} {nameof(RoundToMultiplier)}(this {type} value, {type} multiplier, MidpointRounding rounding = MidpointRounding.ToEven)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn rounding switch");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tMidpointRounding.ToEven => RoundBankingToMultiplier(value, multiplier),");
        WriteLine("\t\t\t\tMidpointRounding.ToZero => RoundToZeroMultiplier(value, multiplier),");
        WriteLine("\t\t\t\tMidpointRounding.AwayFromZero => RoundAwayFromZeroToMultiplier(value, multiplier),");
        WriteLine("\t\t\t\tMidpointRounding.ToPositiveInfinity => RoundUpToMultiplier(value, multiplier),");
        WriteLine("\t\t\t\tMidpointRounding.ToNegativeInfinity => RoundDownToMultiplier(value, multiplier),");
        WriteLine($"\t\t\t\t_ => throw new {nameof(NotSupportedException)}()");
        WriteLine("\t\t\t};");
        WriteLine("\t\t}");
    }
    
    void RoundToMultiplier()
    {
        ForEach(types.Where(NotChar), RoundToMultiplierFunc);
    }

    void AbsFunc(String type)
    {
        if (!IsUnsignedType(type))
        {
            WriteLine($"\t\t/// <inheritdoc cref=\"Math.Abs({type})\"/>");
        }

        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static void Abs(ref {type} value)");
        WriteLine("\t\t{");
        WriteLine("\t\t\tvalue = Abs(value);");
        WriteLine("\t\t}");

        WriteLine(String.Empty);
        
        if (!IsUnsignedType(type))
        {
            WriteLine($"\t\t/// <inheritdoc cref=\"Math.Abs({type})\"/>");
        }
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} Abs(this {type} value)");
        WriteLine("\t\t{");
        WriteLine(!IsUnsignedType(type) ? "\t\t\treturn Math.Abs(value);" : "\t\t\treturn value;");
        WriteLine("\t\t}");
    }

    void Abs()
    {
        ForEach(types, AbsFunc);
    }

    void PowFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Pow)}(this {type} value, {nameof(Byte)} pow)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\t{type} ret = 1;");
        WriteLine("\t\t\twhile (pow != 0)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tif ((pow & 1) == 1)");
        WriteLine("\t\t\t\t{");
        WriteLine("\t\t\t\t\tret *= value;");
        WriteLine("\t\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\t\tvalue *= value;");
        WriteLine("\t\t\t\tpow >>= 1;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\treturn ret;");
        WriteLine("\t\t}");
    }

    void Pow()
    {
        ForEach(types.Where(type => IsIntType(type) && !IsSmallType(type)).Append(biginteger), PowFunc);
    }

    void SqrtFunc(String type)
    {
        WriteLine("\t\t/// <inheritdoc cref=\"Math.Sqrt\"/>");
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Double)} {nameof(Sqrt)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn Math.Sqrt(value);");
        WriteLine("\t\t}");
    }
    
    void Sqrt()
    {
        ForEach(types.Where(type => type != nameof(Decimal) && type != nameof(Char)), SqrtFunc);
    }
    
    void LogFunc(String type)
    {
        WriteLine("\t\t/// <inheritdoc cref=\"Math.Sqrt\"/>");
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Double)} {nameof(Log)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn Math.Log(value);");
        WriteLine("\t\t}");
        
        WriteLine("\t\t/// <inheritdoc cref=\"Math.Sqrt\"/>");
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Double)} {nameof(Log)}(this {type} value, {nameof(Double)} newBase)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn Math.Log(value, newBase);");
        WriteLine("\t\t}");
        
        WriteLine("\t\t/// <inheritdoc cref=\"Math.Sqrt\"/>");
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Double)} {nameof(Log)}2(this {type} value)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn Math.Log2(value);");
        WriteLine("\t\t}");
        
        WriteLine("\t\t/// <inheritdoc cref=\"Math.Sqrt\"/>");
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Double)} {nameof(Log)}10(this {type} value)");
        WriteLine("\t\t{");
        WriteLine("\t\t\treturn Math.Log10(value);");
        WriteLine("\t\t}");
    }
    
    void Log()
    {
        ForEach(types.Where(type => IsIntType(type) && type != nameof(Char)), LogFunc);
    }
    
    void DifferenceFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {ToUnsignedType(type)} {nameof(Difference)}(this {type} value, {type} between)");
        WriteLine("\t\t{");
        if (!IsIntType(type) || IsUnsignedType(type) || type == biginteger)
        {
            WriteLine(IsUnsignedType(type)
                ? $"\t\t\treturn value <= between ? {(IsSmallType(type) ? $"({type}) (between - value)" : "between - value")} : {(IsSmallType(type) ? $"({type}) (value - between)" : "value - between")};"
                : $"\t\t\treturn value <= between ? Abs({(IsSmallType(type) ? $"({type}) (between - value)" : "between - value")}) : Abs({(IsSmallType(type) ? $"({type}) (value - between)" : "value - between")});");
        }
        else
        {
            WriteLine("\t\t\tunchecked");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\treturn {(IsSmallType(type) ? $"({ToUnsignedType(type)}) (value >= between ? ({ToUnsignedType(type)}) value - ({ToUnsignedType(type)}) between : ({ToUnsignedType(type)}) between - ({ToUnsignedType(type)}) value)" : $"value >= between ? ({ToUnsignedType(type)}) value - ({ToUnsignedType(type)}) between : ({ToUnsignedType(type)}) between - ({ToUnsignedType(type)}) value")};");
            WriteLine("\t\t\t}");
        }
        
        WriteLine("\t\t}");
    }
    
    void Difference()
    {
        ForEach(types.Append(biginteger), DifferenceFunc);
    }
    
    void DiscreteDifferenceFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {ToUnsignedType(type)} {nameof(DiscreteDifference)}(this {type} value, {type} between)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(Difference)}(value, between);");
        WriteLine("\t\t}");
    }
    
    void DiscreteDifference()
    {
        ForEach(types.Where(IsIntType), DiscreteDifferenceFunc);
    }
    
    void DiscreteIncludeDifferenceFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {ToUnsignedType(type)} {nameof(DiscreteIncludeDifference)}(this {type} value, {type} between)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(DiscreteIncludeDifference)}(value, between, {ToUnsignedType(type)}.MaxValue);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {ToUnsignedType(type)} {nameof(DiscreteIncludeDifference)}(this {type} value, {type} between, {ToUnsignedType(type)} overflow)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\t{ToUnsignedType(type)} difference = {nameof(DiscreteDifference)}(value, between);");
        WriteLine($"\t\t\treturn {(IsSmallType(type) ? $"difference < {ToUnsignedType(type)}.MaxValue ? ({ToUnsignedType(type)}) (difference + 1) : overflow" : $"difference < {ToUnsignedType(type)}.MaxValue ? difference + 1 : overflow")};");
        WriteLine("\t\t}");
    }
    
    void DiscreteIncludeDifference()
    {
        ForEach(types.Where(IsIntType), DiscreteIncludeDifferenceFunc);
    }
    
    void ToRadiansFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {nameof(Double)} {nameof(ToRadians)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn ToRadians(({nameof(Double)}) value);");
        WriteLine("\t\t}");
    }
    
    void ToRadians()
    {
        ForEach(types.Where(type => IsIntType(type) && type != nameof(Char)), ToRadiansFunc);
    }

    void ToNonZeroFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static void {nameof(ToNonZero)}(ref {type} value)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tvalue = {nameof(ToNonZero)}(value);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static void {nameof(ToNonZero)}(ref {type} value, {type} alternate)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\tvalue = {nameof(ToNonZero)}(value, alternate);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(ToNonZero)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {nameof(ToNonZero)}(value, {(IsSmallType(type) ? $"({type}) " : String.Empty)}1);");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(ToNonZero)}(this {type} value, {type} alternate)");
        WriteLine("\t\t{");
        if (IsIntType(type) || type == nameof(Decimal))
        {
            WriteLine("\t\t\treturn value == 0 ? alternate : value;");
        }
        else
        {
            WriteLine("\t\t\treturn IsEpsilon(value) ? alternate : value;");
        }
        
        WriteLine("\t\t}");
    }
    
    void ToNonZero()
    {
        ForEach(types.Where(NotChar), ToNonZeroFunc);
    }
    
    void ToNonNegativeFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static void {nameof(ToNonNegative)}(ref {type} value)");
        WriteLine("\t\t{");
        if (!IsUnsignedType(type))
        {
            WriteLine($"\t\t\tvalue = {nameof(ToNonNegative)}(value);");
        }
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static void {nameof(ToNonNegative)}(ref {type} value, {type} alternate)");
        WriteLine("\t\t{");
        if (!IsUnsignedType(type))
        {
            WriteLine($"\t\t\tvalue = {nameof(ToNonNegative)}(value, alternate);");
        }
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(ToNonNegative)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {(IsUnsignedType(type) ? "value" : $"value < 0 ? {(IsSmallType(type) ? $"({type}) " : String.Empty)}0 : value")};");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(ToNonNegative)}(this {type} value, {type} alternate)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\treturn {(IsUnsignedType(type) ? "value" : "value < 0 ? alternate : value")};");
        WriteLine("\t\t}");
    }
    
    void ToNonNegative()
    {
        ForEach(types.Where(NotChar), ToNonNegativeFunc);
    }

    void MeanFunc(String type)
    {
        WriteLine("\t\t/// <summary>");
        WriteLine("\t\t/// Calculates the mean value of the provided values.");
        WriteLine("\t\t/// </summary>");
        WriteLine("\t\t/// <param name=\"values\">The values.</param>");
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Mean)}(this IEnumerable<{type}> values)");
        WriteLine("\t\t{");
        WriteLine("\t\t\tUInt32 count = 0;");
        WriteLine($"\t\t\t{(IsIntType(type) ? type == biginteger ? biginteger : IsUnsignedType(type) ? nameof(UInt64) : nameof(Int64) : type == nameof(Single) ? nameof(Double) : type)} sum = 0;");
        WriteLine($"\t\t\tforeach ({type} value in values)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tsum += value;");
        WriteLine("\t\t\t\t++count;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\tif (count == 0 || count > sum)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn 0;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        Boolean remove = type == nameof(Int64) || type == nameof(UInt64) || type == nameof(Double) || type == nameof(Decimal) || type == biginteger;
        WriteLine($"\t\t\treturn {(remove ? "sum / count" : $"({type})(sum / count)")};");
        WriteLine("\t\t}");
    }
    
    void Mean()
    {
        ForEach(types.Where(NotChar).Append(biginteger), MeanFunc);
    }

    void ToBaseFunc(String type)
    {
        WriteLine($"\t\tpublic static {nameof(String)} {nameof(ToBase)}(this {type} value, {nameof(Byte)} @base)");
        WriteLine("\t\t{");
        WriteLine("\t\t\tif (!@base.InRange(MinBase, MaxBase))");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentOutOfRangeException(nameof(@base), @\"Base out of range\");");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);

        if (IsUnsignedType(type))
        {
            WriteLine("\t\t\tif (value <= 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\treturn \"0\";");
            WriteLine("\t\t\t}");
        }
        else
        {
            WriteLine("\t\t\tif (value == 0)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\treturn \"0\";");
            WriteLine("\t\t\t}");
            
            WriteLine(String.Empty);
            
            WriteLine($"\t\t\t{nameof(Boolean)} negative = value < 0;");
            WriteLine("\t\t\tif (negative)");
            WriteLine("\t\t\t{");
            WriteLine("\t\t\t\tAbs(ref value);");
            WriteLine("\t\t\t}");
        }
        
        WriteLine(String.Empty);

        if (type != biginteger)
        {
            WriteLine($"\t\t\t// 64 is the worst cast buffer size for base 2 and {type}.MaxValue");
        }

        WriteLine($"\t\t\t{(type == biginteger ? "Int32 max = (Int32) Round(Log(value, 2), MidpointRounding.ToPositiveInfinity)" : $"const Int32 max = 8 * sizeof({type})")};");
        WriteLine($"\t\t\t{nameof(Int32)} i = max;");
        WriteLine($"\t\t\tSpan<{nameof(Char)}> buffer = stackalloc {nameof(Char)}[max];");

        WriteLine(String.Empty);
        
        WriteLine("\t\t\tdo");
        WriteLine("\t\t\t{");
        WriteLine($"\t\t\t\t{(IsSmallType(type) ? $"{nameof(Int32)}" : $"{type}")} number = value % @base;");
        WriteLine($"\t\t\t\tbuffer[--i] = ({nameof(Char)})(number < 10 ? ZeroChar + number : AlphabetStart + number);");
        WriteLine(String.Empty);
        WriteLine($"\t\t\t\tvalue /= {(type == nameof(SByte) ? $"({nameof(SByte)})" : String.Empty)}@base;");
        WriteLine("\t\t\t} while (value > 0);");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\treturn {(IsUnsignedType(type) ? String.Empty : "$\"{(negative ? \"-\" : String.Empty)}\" + ")}new {nameof(String)}(buffer.Slice(i, max - i));");
        
        WriteLine("\t\t}");
    }

    void ToBase()
    {
        WriteLine("\t\tprivate const Byte MinBase = 2;");
        WriteLine("\t\tprivate const Byte MaxBase = 36;");
        WriteLine("\t\tprivate const Int32 ZeroChar = '0';");
        WriteLine("\t\tprivate const Int32 AlphabetStart = '9' - MinBase;");
        
        WriteLine(String.Empty);

        ForEach(types.Where(type => NotChar(type) && IsIntType(type)).Append(biginteger), ToBaseFunc);
    }

    void SumFunc(String type)
    {
        if (IsSmallType(type) || IsUnsignedType(type) || type == biginteger)
        {
            WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            WriteLine($"\t\tpublic static {type} {nameof(Sum)}(this IEnumerable<{type}> source)");
            WriteLine("\t\t{");

            WriteLine("\t\t\tchecked");
            WriteLine("\t\t\t{");
            WriteLine($"\t\t\t\treturn source.Aggregate{(type != nameof(Int32) ? $"<{type}, {type}>" : String.Empty)}(0, (current, value) => {(IsSmallType(type) ? $"({type}) (current + value)" : "current + value")});");
            WriteLine("\t\t\t}");
            
            WriteLine("\t\t}");
        
            WriteLine(String.Empty);
        }
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Sum)}(this IEnumerable<{type}> source, {type} overflow)");
        WriteLine("\t\t{");
        WriteLine("\t\t\ttry");
        WriteLine("\t\t\t{");
        WriteLine($"\t\t\t\treturn source.{nameof(Sum)}();");
        WriteLine("\t\t\t}");
        WriteLine("\t\t\tcatch (OverflowException)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn overflow;");
        WriteLine("\t\t\t}");
        WriteLine("\t\t}");
    }
    
    void Sum()
    {
        ForEach(types.Where(NotChar).Append(biginteger), SumFunc);
    }

    void MultiplyFunc(String type)
    {
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Multiply)}(this IEnumerable<{type}> source)");
        WriteLine("\t\t{");

        WriteLine("\t\t\tif (source is null)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentNullException(nameof(source));");
        WriteLine("\t\t\t}");
        WriteLine(String.Empty);
        WriteLine("\t\t\tchecked");
        WriteLine("\t\t\t{");
        WriteLine($"\t\t\t\tusing IEnumerator<{type}> enumerator = source.GetEnumerator();");
        WriteLine(String.Empty);
        WriteLine("\t\t\t\tif (!enumerator.MoveNext() || enumerator.Current == 0)");
        WriteLine("\t\t\t\t{");
        WriteLine("\t\t\t\t\treturn 0;");
        WriteLine("\t\t\t\t}");
        WriteLine(String.Empty);
        WriteLine($"\t\t\t\t{type} result = enumerator.Current;");
        WriteLine(String.Empty);
        WriteLine("\t\t\t\twhile (enumerator.MoveNext())");
        WriteLine("\t\t\t\t{");
        WriteLine("\t\t\t\t\tswitch (enumerator.Current)");
        WriteLine("\t\t\t\t\t{");
        WriteLine($"\t\t\t\t\t\tcase {(type == biginteger ? "BigInteger.Zero" : "0")}:");
        WriteLine("\t\t\t\t\t\t\treturn 0;");
        WriteLine($"\t\t\t\t\t\tcase {(type == biginteger ? "BigInteger.One" : "1")}:");
        WriteLine("\t\t\t\t\t\t\tcontinue;");
        WriteLine("\t\t\t\t\t\tdefault:");
        WriteLine("\t\t\t\t\t\t\tresult *= enumerator.Current;");
        WriteLine("\t\t\t\t\t\t\tbreak;");
        WriteLine("\t\t\t\t\t}");
        WriteLine("\t\t\t\t}");
        WriteLine(String.Empty);
        WriteLine("\t\t\t\treturn result;");
        WriteLine("\t\t\t}");
        WriteLine("\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        WriteLine($"\t\tpublic static {type} {nameof(Multiply)}(this IEnumerable<{type}> source, {type} overflow)");
        WriteLine("\t\t{");
        WriteLine("\t\t\ttry");
        WriteLine("\t\t\t{");
        WriteLine($"\t\t\t\treturn source.{nameof(Multiply)}();");
        WriteLine("\t\t\t}");
        WriteLine("\t\t\tcatch (OverflowException)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn overflow;");
        WriteLine("\t\t\t}");
        WriteLine("\t\t}");
    }

    void Multiply()
    {
        ForEach(types.Where(NotChar), MultiplyFunc);
    }
    
    
    void AverageFunc(String type)
    {
        WriteLine("\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"ReSharper\", \"SuspiciousTypeConversion.Global\")]");
        WriteLine($"\t\tpublic static {(type == nameof(Decimal) ? nameof(Decimal) : nameof(Double))} {nameof(Average)}(this IEnumerable<{type}> source)");
        WriteLine("\t\t{");
        WriteLine("\t\t\tif (source is null)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentNullException(nameof(source));");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\treturn source.Cast<{nameof(Double)}>().Average();");
        WriteLine("\t\t}");
    }
    
    void Average()
    {
        ForEach(types.Where(type => IsSmallType(type) || IsUnsignedType(type)).Where(NotChar), AverageFunc);
    }

    void VarianceFunc(String type)
    {
        WriteLine($"\t\tpublic static {(type == nameof(Decimal) ? nameof(Decimal) : nameof(Double))} {nameof(Variance)}(this IEnumerable<{type}> source)");
        WriteLine("\t\t{");
        WriteLine("\t\t\tif (source is null)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentNullException(nameof(source));");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\tICollection<{type}> values = source as ICollection<{type}> ?? source.ToList();");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\tif (values.Count <= 0)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treturn 0;");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine($"\t\t\t{(type == nameof(Decimal) ? nameof(Decimal) : nameof(Double))} mean = values.Average();");
        WriteLine($"\t\t\t{(type == nameof(Decimal) ? nameof(Decimal) : nameof(Double))} sum = values.Sum(x => (x - mean).Pow(2));");
        WriteLine("\t\t\treturn sum / values.Count;");
        
        WriteLine("\t\t}");
    }
    
    void Variance()
    {
        ForEach(types.Where(NotChar), VarianceFunc);
    }
    
    void StandardDeviationFunc(String type)
    {
        WriteLine($"\t\tpublic static {(type == nameof(Decimal) ? nameof(Decimal) : nameof(Double))} {nameof(StandardDeviation)}(this IEnumerable<{type}> source)");
        WriteLine("\t\t{");
        WriteLine("\t\t\tif (source is null)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\tthrow new ArgumentNullException(nameof(source));");
        WriteLine("\t\t\t}");
        
        WriteLine(String.Empty);
        
        WriteLine("\t\t\treturn source.Variance().Sqrt();");
        WriteLine("\t\t}");
    }
    
    void StandardDeviation()
    {
        ForEach(types.Where(NotChar), StandardDeviationFunc, false);
    }

    void ReverseFunc(String type)
    {
        WriteLine("\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"ReSharper\", \"SuspiciousTypeConversion.Global\")]");
        WriteLine($"\t\tpublic static {(IsSmallType(type) ? nameof(Int32) : type)} {nameof(Reverse)}(this {type} value)");
        WriteLine("\t\t{");
        WriteLine($"\t\t\t{(IsSmallType(type) ? nameof(Int32) : type)} reverse = 0;");
        WriteLine(String.Empty);
        WriteLine("\t\t\twhile (value != 0)");
        WriteLine("\t\t\t{");
        WriteLine("\t\t\t\treverse = reverse * 10 + value % 10;");
        WriteLine("\t\t\t\tvalue /= 10;");
        WriteLine("\t\t\t}");
        WriteLine(String.Empty);
        WriteLine("\t\t\treturn reverse;");
        WriteLine("\t\t}");
    }

    void Reverse()
    {
        ForEach(types.Where(NotChar).Where(IsIntType), ReverseFunc);
    }
#>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("ReSharper", "RedundantOverflowCheckingContext")]
    public static partial class MathUtils
    {
<#
    Min();
    WriteLine(String.Empty);
    Max();
    WriteLine(String.Empty);
    Factorial();
    WriteLine(String.Empty);
    Range();
    WriteLine(String.Empty);
    RangeInclude();
    WriteLine(String.Empty);
    ToRange();
    WriteLine(String.Empty);
    InRange();
    WriteLine(String.Empty);
    IsPositive();
    WriteLine(String.Empty);
    IsNegative();
    WriteLine(String.Empty);
    ToSign();
    WriteLine(String.Empty);
    RoundToMultiplier();
    WriteLine(String.Empty);
    Abs();
    WriteLine(String.Empty);
    Pow();
    WriteLine(String.Empty);
    Sqrt();
    WriteLine(String.Empty);
    Log();
    WriteLine(String.Empty);
    Difference();
    WriteLine(String.Empty);
    DiscreteDifference();
    WriteLine(String.Empty);
    DiscreteIncludeDifference();
    WriteLine(String.Empty);
    ToRadians();
    WriteLine(String.Empty);
    ToNonZero();
    WriteLine(String.Empty);
    ToNonNegative();
    WriteLine(String.Empty);
    Mean();
    WriteLine(String.Empty);
    ToBase();
    WriteLine(String.Empty);
    Sum();
    WriteLine(String.Empty);
    Multiply();
    WriteLine(String.Empty);
    Average();
    WriteLine(String.Empty);
    Variance();
    WriteLine(String.Empty);
    StandardDeviation();
    WriteLine(String.Empty);
    Reverse();
#>
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("ReSharper", "InvertIf")]
    public static class MathUnsafe
    {
<#
    foreach (String @operator in operands.Keys)
    {
        Functions(@operator);
    }
#>
    }
}