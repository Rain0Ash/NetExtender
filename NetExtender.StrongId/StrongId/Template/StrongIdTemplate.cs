// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

using System;
using System.Collections.Immutable;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using NetExtender.StrongId.Attributes;

namespace NetExtender.StrongId.Template
{
    [SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
    internal static class StrongIdTemplate
    {
        public const String StrongId = $"{nameof(NetExtender)}.{nameof(StrongId)}";
        private const String StrongIdSource = $"{StrongId}.{nameof(StrongId)}";
        private const String Template = $"{StrongIdSource}.{nameof(Template)}";
        private const String Generic = $"{Template}.{nameof(Generic)}";

        public const String TypeConverterAttributeSource = $"    [{nameof(System)}.{nameof(System.ComponentModel)}.{nameof(TypeConverter)}(typeof(STRONGID{nameof(TypeConverter)}))]";
        public const String NewtonsoftJsonAttributeSource = "    [Newtonsoft.Json.JsonConverter(typeof(STRONGIDNewtonsoftJsonConverter))]";
        public const String TextJsonAttributeSource = "    [System.Text.Json.Serialization.JsonConverter(typeof(STRONGIDTextJsonConverter))]";
        public const String SwaggerSchemaFilterAttributeSource = "    [Swashbuckle.AspNetCore.Annotations.SwaggerSchemaFilter(typeof(STRONGIDSchemaFilter))]";

        private static Assembly? assembly;
        public static Assembly Assembly
        {
            get
            {
                return assembly ??= typeof(StrongIdTemplate).Assembly;
            }
        }

        private static String? attributesource;
        public static String AttributeSource
        {
            get
            {
                return attributesource ??= LoadAttributeTemplateForEmitting(nameof(StrongIdAttribute));
            }
        }

        private static String? assemblyattributesource;
        public static String AssemblyAttributeSource
        {
            get
            {
                return assemblyattributesource ??= LoadAttributeTemplateForEmitting(nameof(StrongIdAssemblyAttribute));
            }
        }

        private static String? underlyingtypesource;
        public static String UnderlyingTypeSource
        {
            get
            {
                return underlyingtypesource ??= LoadTemplateForEmitting(nameof(StrongIdUnderlyingType));
            }
        }

        private static String? conversiontypesource;
        public static String ConversionTypeSource
        {
            get
            {
                return conversiontypesource ??= LoadTemplateForEmitting(nameof(StrongIdConversionType));
            }
        }

        private static String? convertertypesource;
        public static String ConverterTypeSource
        {
            get
            {
                return convertertypesource ??= LoadTemplateForEmitting(nameof(StrongIdConverterType));
            }
        }

        private static String? interfacetypesource;
        public static String InterfaceTypeSource
        {
            get
            {
                return interfacetypesource ??= LoadTemplateForEmitting(nameof(StrongIdInterfaceType));
            }
        }

        private static String? interfacesource;
        public static String InterfaceSource
        {
            get
            {
                return interfacesource ??= LoadInterfaceTemplateForEmitting(nameof(IStrongId));
            }
        }

        private static String? autogeneratedheader;
        private static String AutoGeneratedHeader
        {
            get
            {
                return autogeneratedheader ??= LoadResource($"{Generic}.{nameof(StrongId)}{nameof(AutoGeneratedHeader)}.cs");
            }
        }

        private static ImmutableDictionary<StrongIdUnderlyingType, Resource>? @internal;
        private static ImmutableDictionary<StrongIdUnderlyingType, Resource> Resources
        {
            get
            {
                if (@internal is not null)
                {
                    return @internal;
                }

                ImmutableDictionary<StrongIdUnderlyingType, Resource>.Builder builder = ImmutableDictionary.CreateBuilder<StrongIdUnderlyingType, Resource>();

                foreach (Object? item in Enum.GetValues(typeof(StrongIdUnderlyingType)))
                {
                    StrongIdUnderlyingType type = (StrongIdUnderlyingType) item;
                    
                    //TODO: Добавить конвершены к BigInteger и обратно ко всем типам Dapper/Json
                    if (type >= StrongIdUnderlyingType.BigInteger)
                    {
                        continue;
                    }
                    
                    builder.Add(type, new Resource(type));
                }

                return @internal ??= builder.ToImmutable();
            }
        }

        public static Resource Get(StrongIdUnderlyingType type)
        {
            return Resources.TryGetValue(type, out Resource resources) ? resources : throw new InvalidOperationException($"Invalid enum type: {type}");
        }

        private static String LoadResource(String resource)
        {
            if (resource is null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            if (TryLoadResource(resource) is String result)
            {
                return result;
            }

            throw new StrongIdTemplateLoadException(Assembly, resource);
        }

        private static String? TryLoadResource(String resource)
        {
            if (resource is null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            using Stream? stream = Assembly.GetManifestResourceStream(resource);

            if (stream is null)
            {
                return null;
            }

            using StreamReader reader = new StreamReader(stream, Encoding.UTF8);
            return reader.ReadToEnd();
        }

        private static String LoadTemplateForEmitting(String resource)
        {
            return AutoGeneratedHeader + LoadResource($"{StrongIdSource}.{resource}.cs");
        }

        private static String LoadAttributeTemplateForEmitting(String resource)
        {
            return AutoGeneratedHeader + LoadResource($"{StrongIdSource}.{nameof(Attributes)}.{resource}.cs");
        }

        private static String LoadInterfaceTemplateForEmitting(String resource)
        {
            return AutoGeneratedHeader + LoadResource($"{StrongIdSource}.Interfaces.{resource}.cs");
        }

        public readonly struct Resource
        {
            public String Type { get; }
            public String Name { get; }
            public String Header { get; }
            public String Declaration { get; }
            public String ImplicitTo { get; }
            public String ExplicitTo { get; }
            public String ImplicitFrom { get; }
            public String ExplicitFrom { get; }
            public String EqualityOperators { get; }
            public String ComparableOperators { get; }
            public String Template { get; }
            public String Properties { get; }
            public String Constructors { get; }
            public String Methods { get; }
            public String TypeConverter { get; }
            public String TextJsonConverter { get; }
            public String NewtonsoftJsonConverter { get; }
            public String EntityFrameworkValueConverter { get; }
            public String DapperTypeHandler { get; }
            public String SwaggerSchemaFilter { get; }
            public String Parseable { get; }
            public String Equatable { get; }
            public String Comparable { get; }
            public String Formattable { get; }
            public String Serializable { get; }
            public Boolean Nullable { get; }
            public String SwaggerType { get; }
            public String? SwaggerFormat { get; }

            public Resource(StrongIdUnderlyingType type)
            {
                String? typename = Enum.GetName(typeof(StrongIdUnderlyingType), type)?.Replace("Nullable", ".Nullable");

                if (typename is null)
                {
                    throw new NotSupportedException($"Invalid enum type: {type}");
                }

                String @namespace = $"{StrongIdTemplate.Template}.{typename}.{typename.Remove(".Nullable")}";

                (Type, Name) = type.UnderlyingType();
                Nullable = type.IsNullable();
                Header = AutoGeneratedHeader;
                Declaration = Load(@namespace, nameof(Declaration), Nullable);
                ImplicitTo = Load(@namespace, nameof(ImplicitTo), Nullable);
                ExplicitTo = Load(@namespace, nameof(ExplicitTo), Nullable);
                ImplicitFrom = Load(@namespace, nameof(ImplicitFrom), Nullable);
                ExplicitFrom = Load(@namespace, nameof(ExplicitFrom), Nullable);
                EqualityOperators = Load(@namespace, nameof(EqualityOperators), Nullable);
                ComparableOperators = Load(@namespace, nameof(ComparableOperators), Nullable);
                Template = Load(@namespace, nameof(Template), Nullable);
                Properties = Load(@namespace, nameof(Properties), Nullable);
                Constructors = Load(@namespace, nameof(Constructors), Nullable);
                Methods = Load(@namespace, nameof(Methods), Nullable);
                TypeConverter = Load(@namespace, nameof(TypeConverter), Nullable);
                TextJsonConverter = Load(@namespace, nameof(TextJsonConverter), Nullable);
                NewtonsoftJsonConverter = Load(@namespace, nameof(NewtonsoftJsonConverter), Nullable);
                TypeConverter = Load(@namespace, nameof(TypeConverter), Nullable);
                EntityFrameworkValueConverter = Load(@namespace, nameof(EntityFrameworkValueConverter), Nullable);
                DapperTypeHandler = Load(@namespace, nameof(DapperTypeHandler), Nullable);
                SwaggerSchemaFilter = Load(@namespace, nameof(SwaggerSchemaFilter), Nullable);
                Parseable = Load(@namespace, nameof(Parseable), Nullable);
                Equatable = Load(@namespace, nameof(Equatable), Nullable);
                Comparable = Load(@namespace, nameof(Comparable), Nullable);
                Formattable = Load(@namespace, nameof(Formattable), Nullable);
                Serializable = Load(@namespace, nameof(Serializable), Nullable);
                (SwaggerType, SwaggerFormat) = type.Swagger();
            }

            private static String Load(String @namespace, String property, Boolean nullable)
            {
                if (String.IsNullOrEmpty(property))
                {
                    throw new ArgumentException("Value cannot be null or empty.", nameof(property));
                }

                return TryLoadResource($"{@namespace}.{property}.cs")
                       ?? (nullable ? TryLoadResource($"{Generic}.{nameof(Nullable)}.{property}.cs") : null)
                       ?? TryLoadResource($"{Generic}.{property}.cs")
                       ?? throw new StrongIdTemplateLoadException(Assembly, $"{@namespace}.{property}.cs");
            }
        }
    }

    [Serializable]
    public class StrongIdTemplateLoadException : InvalidOperationException
    {
        public StrongIdTemplateLoadException(Assembly assembly, String resource)
            : base(Initialize(assembly, resource))
        {
        }

        protected StrongIdTemplateLoadException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        private static String Initialize(Assembly assembly, String resource)
        {
            if (assembly is null)
            {
                throw new ArgumentNullException(nameof(assembly));
            }

            if (resource is null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            String[] exists = assembly.GetManifestResourceNames();
            throw new ArgumentException($"Could not find embedded resource {resource}. Available names: {String.Join(", ", exists)}");
        }
    }
}